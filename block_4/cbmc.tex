%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Aufgabe
\Aufgabe[Bounded Model Checking\hfill\textbf{(1.5 Point)}]
Consider the following Program:

\lstinputlisting[basicstyle=\footnotesize]{main.c}

The Matrix $G$ models a graph with $N$ nodes, i.e, $G[i][j]$ is true iff there is a directed edge from node $i$ to node $j$. The method $\mathit{nondet}$ chooses an integer non-deterministically.

\begin{enumerate}
	\item Use CBMC to find the lowest value for $K$ such that the assertion at the end of the program can be violated. What does it mean that the error state is or is not reachable for a given graph $G$ and a given value $K$?

	\item Perform an unwinding of the loop for $K = 3$.
				
	\item Transform the unwinded program into the SSA form.
	
	\item Build a semantically equivalent SMT formula from the SSA form. {\em Note:} A call to $\mathit{nondet}$ can be modeled by introducing a new integer variable.

        \item Can you draw a conclusion about the satisfiability of the formula by comparing the value for $K$ that you determined under $(a)$ with the number of times the loop was unwinded for building the formula? Check whether the formula can be satisfied (You may use an SMT solver such as {\em Yices} or {\em Z3}) to be sure that the result of the satisfiability check is consistent with your expectation.

\end{enumerate}

\vspace{0.5cm}

$\ddot\smile$ \textbf{Solution}\\
\begin{enumerate}
\item
The lowest value $K$ for a violated assertion is $1$.

\item[(b) \& (c)] \quad
\medskip
\begin{lstlisting}[	frame=lines, mathescape=true,
					caption={ Unwinded code in SSA form:},
					label={unw_func}]
void main() {
	// Intialization:
	bool G[N][N] = {{$\ldots$}};
	bool result$_0$ = 1;
	int node$_0$ = 0;
	int next$_0$ = 0;
	int i$_0$ = 0;
	
	// Unwinding of the for-loop for $K = 3$:
	// First iteration:
	if(i$_0$ < K) {
		next$_1$ = nondet() % N;
		result$_1$ = result$_0$ && G[node$_0$][next$_1$];
		node$_1$ = next$_1$;
		i$_1$ = i$_0$ + 1;
		// Second iteration:
		if(i$_1$ < K) {
			next$_2$ = nondet() % N;
			result$_2$ = result$_1$ && G[node$_1$][next$_2$];
			node$_2$ = next$_2$;
			i$_2$ = i$_1$ + 1;
			result$_3$ = result$_2$;
			// Third iteration + termination:
			if(i$_2$ < K) {
				next$_3$ = nondet() % N;
				result$_3$ = result$_2$ && G[node$_2$][next$_3$];
				node$_3$ = next$_3$;
				i$_3$ = i$_2$ + 1;
				assert(!(i$_3$ < K));
			}
		}
	}
	result$_4$ = result$_3$ && node$_3$ == 0) && (K > 0);

	assert(!result$_4$);
}
\end{lstlisting}

\item[(d)]
\item[(e)]
\end{enumerate}